\chapter*{Lesson 4}

\section{Negligible function}

What is exactly a negligible function? Below here there is a possible interpretation of this notion:
\begin{quotation}
    ``In real life, we can just consider adversaries with limited computational power; even if every non-perfectly secure authentication scheme can resist to unbounded computational power, the true unbounded computational power doesn't exist at all. So, it's reasonable to consider just bounded adversaries.

    So consider a scheme $\Pi$ where the only attack against it is brute-force attack. We consider $\Pi$ to be secure if it cannot be broken by a brute-force attack in polynomial time.

    The idea of \textbf{negligible probability} encompasses this exact notion. In $\Pi$, let's say that we have a polynomial-bounded adversary. Brute force attack is not an option.

    But instead of brute force, the adversary can try (a polynomial number of) random values and hope to guess the right one. In this case, we define security using negligible functions: The probability of success has to be smaller than the reciprocal of any polynomial function.

    And this makes a lot of sense: if the success probability for an individual guess is a reciprocal of a polynomial function, then the adversary can try a polynomial amount of guesses and succeed with high probability. If the overall success rate is $\frac{1}{poly(\lambda)}$ then we consider this attempt a feasible attack to the scheme, which makes the latter insecure.

    So, we require that the success probability must be less than the reciprocal of every polynomial function. This way, even if the adversary tries $poly(\lambda)$ guesses, it will not be significant since it will only have tried: $\frac{poly(\lambda)}{superpoly(\lambda)}$\footnote{If we design a function hard for $superpoly(\lambda)$ possible attempts and the attacker completed $poly(\lambda)$ attempts, he has just $ \P [\frac{poly(\lambda)}{superpoly(\lambda)}] $ of finding the key to break the scheme}

    As $\lambda$ grows, the denominator grows far faster than the numerator and the success probability will not be significant.\footnote{https://crypto.stackexchange.com/questions/5832/what-exactly-is-a-negligible-and-non-negligible-function}''

\end{quotation}

\subsubsection{Definition}
Let $\nu : \mathbb{N} \to [0,1]$ be a function. Then it is deemed \textbf{negligible} iff:
\begin{equation*}
    \forall p(\lambda) \in poly(\lambda) \implies \nu(\lambda) \in o(\frac{1}{p(\lambda)})
\end{equation*}

\begin{exercise}
    Let $p(\lambda), p'(\lambda) \in poly(\lambda)$ and $\nu(\lambda), \nu'(\lambda) \in \negl\lambda$. Then prove the following:

    \begin{enumerate}
        \item $p(\lambda) \cdot p'( \lambda) \in  \poly(\lambda)$
        \item $\nu(\lambda) + \nu'(\lambda) \in \negl\lambda$
    \end{enumerate} 
\end{exercise}

\begin{solution}[1.1]

    \todo{Questa soluzione usa disuguaglianze deboli; per essere negligibile una funzione dev'essere strettamente minore di un polinomiale inverso. Da approfondire}

    We need to show that for any $c \in \mathbb{N} $, then there is $n_{0}$ such that $\forall n > n_{0} \implies h(n) \leq n^{-c}$.
    
    So, consider an arbitrary $c \in \mathbb{N}$. Then, since $c+1 \in \mathbb{N} $, and both $f$ and $g$ are negligible, there exists $n_{f}$ and $n_{g}$ such that:
    \begin{align*}
        \forall n \geq n_{f} &\implies f(n) \leq n^{-(c+1)} \\
        \forall n \geq n_{g} &\implies g(n) \leq n^{-(c+1)}
    \end{align*}

    Fix $n_{0} = \max(n_{f}, n_{g})$. Then, since $n \geq n_{0} \geq 2$, $\forall n \geq n_{0}$ we have:
    \begin{align*}
        h(n) &= f(n)+g(n) \\
        &\leq n^{-(c+1)} + n^{-(c+1)} \\
        &= 2n^{-(c+1)} \\
        &\leq n^{-c}
    \end{align*}
    Thus we conclude $h(n)$ is negligible.
\end{solution}


\section{One-Way Functions}

A One-Way Function (\textsc{owf}) is a function that is ``easy to compute'', but ``hard to invert''.

\begin{definition}    
    Let $f : \{0,1\}^{n(\lambda)} \to {0,1}^{n(\lambda)}$ be a function. Then it is a \textsc{owf} iff:

    \begin{equation}
        \forall\; \textsc{ppt}\; \A\;
        \exists\nu(\lambda) \in \negl{x} :
        \Pr \left[ \textsc{Game}_{f,A}^\textsc{owf} (\lambda) = 1 \right]
        \leq \nu(\lambda)
    \end{equation}

\end{definition}


\begin{cryptogame}{owfdef}{One-Way Function hardness}{owf}
    \receive{\shortstack[l]{
        $x \pickUAR \{0,1\}^{n}$ \\
        $y = f(x)$}}
    {$y$}
    {}

    \postlevel

    \send{}
    {$x'$}
    {\textsc{Output 1 iff} $f(x')=y$}

\end{cryptogame}

Do note that the game does not look for the equality $x' = x$, but rather for the equality of their images computed by $f$.

\pagebreak

\begin{exercise}
    \
    \begin{enumerate}
        \item Show that there exists an inefficient adversary that wins $\textsc{Game}^\textsc{owf}$ with probability 1
        \item Show that there exists an efficient adversary that wins $\textsc{Game}^\textsc{owf}$ with probability $2^{-n}$
    \end{enumerate}
\end{exercise}


\subsubsection{One-Way puzzles}
A one-way function can be thought as a function which is very efficient in generating puzzles that are very hard to solve. Furthermore, the person generating the puzzle knows a solution to it and can efficiently verify the validity of (possible other) solutions to the puzzle.

For a given couple $(\mathcal{P}_\textsc{gen},\mathcal{P}_\textsc{ver})$ of a puzzle generator and a puzzle verifier, we have:

\begin{cryptogame}{owpuzzle}{The puzzle game}{puzzle}
    \receive{$(x, y) \pickUAR \mathcal{P}_\textsc{gen}$}
    {$y$}
    {}

    \postlevel

    \send{}
    {$x'$}
    {\textsc{Output} $\mathcal{P}_\textsc{ver}(x', y)$}

\end{cryptogame}

So, we can say that one-way Puzzle is a problem in \textsc{np} (because solutions are easy to verify ), but not in \textsc{p} (because a solution is
hard to provide).

\subsection{Impagliazzo's Worlds}

Suppose to have Gauss, a genius child, and his professor. The professor gives to Gauss some mathematical problems, and Gauss wants to solve them all.

Imagine now that, if using one-way functions, the problem is $f(x)$, and its solution is $x$. According to Impagliazzo, we live in one of these possible worlds:
\begin{itemize}
    \item \textit{Algorithmica}: $\textsc{P} = \textsc{NP}$, meaning all efficiently verifiable problems are also efficiently solvable. 
    
    The Professor can try as hard as possible to create a hard scheme, but he won't succeed because Gauss will always be able to efficiently break it using the verification procedure to compute the solution

    \item \textit{Heuristica}: \textsc{NP} problems are hard to solve in the worst case but easy on average. 
    
    The professor, with some effort, can create a game difficult enough, but Gauss will solve it anyway; here there are some problems that the professor cannot find a solution to

    \item \textit{Pessiland}: \textsc{NP} problems are hard on average but no one-way functions exist
    
    \item \textit{Minicrypt}: One-way functions exist but public-key cryptography is impractical
    
    \item \textit{Cryptomania}: public-key cryptography is possible: two parties can exchange secret messages over open channels
\end{itemize}
    
\section{Computational Indistinguishability}
Distribution ensemble $X={X_{\lambda \in \mathbb{N}}}$ and $Y={Y_{\lambda \in
\mathbb{N} }}$  are a sequence of distributions.

\begin{definition}
    $X$ and $Y$ are computationally \textbf{indistinguishable} $(X
    \approx_{c} Y)$ if $ \forall. PPT. D, \exists \nu(\lambda) \in
    \negl{\lambda} $ such that
    \begin{equation}
    |   \P [ D(X_{\lambda})=1 ] - \P [ D(Y_{\lambda})=1 ]   | \le \nu(\lambda) 
    \end{equation}
\end{definition}


Suppose we have this mental game: a Distinguisher $D$ receives the value $z$.
This value has been chosen by me , the Challenger, among $X_{\lambda}$ and
$Y_{\lambda}$ , and the Distinguisher has to \textit{distinguish} which was the
source of $z$.
What does this formula mean?\\
This formula means that, fixed $1$ as one of the sources, the
\textit{probability}  that D says "1!" when I pick $z$ from $X_{\lambda}$ is \textbf{not
so far}  from the \textit{probability}  that D says "1!" when I pick $z$ from
$Y_{\lambda}$ .\\
\\
So, this means that, when this property is verified by two random variables, 
there isn't too much \textit{difference} between the two
variables in terms of exposed information (reachable by D), otherwise the distance 
between the two probabilities should be much more than a \textit{negligible}
quantity .\\
What's the deep meaning of this formula? This is something to do.

\begin{lemma}\label{lem:tria}
    If $X \approx_{c} Y  $ then $ \forall PPT. f$  we have $f(x) \approx_{c}
    f(y)$.
\end{lemma}

\begin{proof}
    [by contraddiction]
We want to show that  $ f(x) \approx_{c} f(y) $ . So, let's suppose this property is not true.\\
 Assume $ \exists PPT.f, D' $ and some $ p'(\lambda) \in \poly{\lambda} $ such that
    \begin{equation}
        |\P [ D '(f(x))=1 ] - \P [ \D '(f(y))=1 ]| > \frac{1}{p'(\lambda)}
    \end{equation}.

So D' which can distinguish $f(x)$ and $f(y)$ :


\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{$ \D $}
      \newinst[5]{B}{$ \C $} % Increase "5" to widen
      
      % Message from Alice to Bob, with precomputations
      \postlevel
      \mess{B}{z}{A}
      \node[anchor=west] at (mess from) {\shortstack[r]{
      		$  z \leftarrow\$ X_{\lambda}  $ 
            \\
            $  z \leftarrow\$ Y_{\lambda}  $ }};
      
      % Message from Bob to Alice, with computations by both sides
      \postlevel
      \mess{A}{ \small{sourcename }}{B}
      \node[anchor=west] at (mess to) {};
      
      \sdend{}
   \end{tikzpicture}
   \caption{Distinguisher of $f(x) \approx_{c} f(y)$}
   \label{fig:dis1}
\end{figure}.
But , if this kind of distinguisher would exist, we could use this distinguisher
to distinguish$X$ and $Y$ .
\newpage
We can build something like this:

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{D}{$\D '$}
      \newinst[3]{A}{$ \D $}
      \newinst[3]{B}{$  $} % Increase "5" to widen
      
      % Message from Alice to Bob, with precomputations
      \postlevel
      \mess{B}{z}{A}
      \node[anchor=west] at (mess from) {\shortstack[l]{
      		$  z \leftarrow\$ X_{\lambda}  $ 
            \\
            $  z \leftarrow\$ Y_{\lambda}  $ }};
      
        \mess{A}{f(z)}{D}
      \node[anchor=west] at (mess to) {  };
      % Message from Bob to Alice, with computations by both sides
      \postlevel
      \mess{D}{$f(x) \text{ or } f(y)$}{A}
      \node[anchor=west] at (mess to) {  };

      \mess{A}{sourcename}{B}
      \node[anchor=west] at (mess to) {  };
      
      \sdend{}
   \end{tikzpicture}
   \caption{The reduction done}
   \label{fig:red1}
\end{figure}
So, if D' could distinguish between f(x) and f(y), this means that its output
can be used to distuinguish also the main problem  in polinomial time (since D'
is a PPT), the distinction about
$X_{\lambda}$ and $Y_{\lambda}$.\\
\end{proof}
\section{Pseudorandom Generator (PRG)}

A deterministic function $G:\{0,1\}^{\lambda} \to \{0,1\}^{\lambda + l(
\lambda)} $ is a PRG if :
\begin{itemize}
    \item G is polinomial time, so it runs in polinomial time
    \item $| G(s) | = \lambda + l(\lambda)$
    \item $G(U_{\lambda}) \approx_{c} U_{\lambda + l(\lambda)}$
\end{itemize}


\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{$ \D $}
      \newinst[5]{B}{$ C^{PRG} $} % Increase "5" to widen
      
      % Message from Alice to Bob, with precomputations
      \postlevel
      \mess{B}{z}{A}
      \node[anchor=west] at (mess from) {\shortstack[r]{
                  $  z=G(s); s \leftarrow\$ U_{\lambda}  $  
            \\
    $ z \leftarrow\$ U_{\lambda} $ }};
      
      % Message from Bob to Alice, with computations by both sides
      \postlevel
      \mess{A}{sourcename}{B}
      \node[anchor=west] at (mess to) {  };
      
      \sdend{}
   \end{tikzpicture}
   \caption{Pseudorandom generator game }
   \label{fig:prggame}
\end{figure}

So, if we take $s \leftarrow\$ U_{\lambda}$, the output of $G$ will be
indistinguishable from a random draw from $U_{\lambda}$.\\
